#pragma config(Sensor, in1,    armPot,         sensorPotentiometer)
#pragma config(Sensor, dgtl1,  liftPot,        sensorQuadEncoder)
#pragma config(Motor,  port1,           leftBack,      tmotorVex393_HBridge, openLoop, driveLeft)
#pragma config(Motor,  port2,           leftFront,     tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           lift,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           roller,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           mogo,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rightFront,    tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port10,          rightBack,     tmotorVex393_HBridge, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int MAX_NUM_CONES = 10;
const int numStackStates = 10;
const int armDefault = 0;
const int liftDefault = 0;

int liftConeValues[MAX_NUM_CONES];
//the sequence of poitions that you want for the stack
//the arm positions while stacking
int armStackValues[numStackStates];
//the lift positions while stacking. If you want the lift position to be related to how big the stack is,
//then add " + STACK_HEIGHT" to the end of the assignment.
string liftStackValues[numStackStates];
//the roller positions while stacking. 0 => dont move, 1 => rotate in positive dir, -1 => rotate in negative dir.
int rollerStackValues[numStackStates];

int numCones = 0;

int powerDriveLeft = 0;
int powerDriveRight = 0;

int deadZone = 20;

int stackState = 0;

int minAccuracy = 10;

int hit = 0;

bool cancelStackComplete = true;
bool clearStackComplete = true;
bool stackComplete = true;


int capVal(int num, int max, int min)
{
	if(num > max)
	{
		return max;
	}
	else if(num < min)
	{
		return min;
	}
	return num;
}

void drive(int chnn3,int chnn4)
{
	//dead zone, area where joystick doesn't respond.
	if(abs(chnn3) < deadZone && abs(chnn4) < deadZone)
	{
		powerDriveLeft = 0;
		powerDriveRight = 0;
	}
	//get the base power
	int power = (int)sqrt(chnn3 * chnn3 + chnn4 * chnn4) * abs(chnn3)/chnn3;

	//get the actual drive power
	powerDriveLeft = capVal (power + 2 * chnn4, power, -power);
	powerDriveRight = capVal (power - 2 * chnn4, power, -power);

	//assign the actual drive power
	motor[leftFront] = powerDriveLeft;
	motor[leftBack] = powerDriveLeft;
	motor[rightFront] = powerDriveRight;
	motor[rightBack] = powerDriveRight;
}


//moves the arm and lift to a certain position
bool moveTo(int armPos, int liftPos, int rollerDir)
{
	 motor[lift] = capVal((SensorValue[liftPot] - liftPos),100, -100);
	 motor[arm] = capVal((SensorValue[armPot] - armPos),100, -100);
	 motor[roller] = 100 * rollerDir;
	 return abs(SensorValue[liftPot] - liftPos) < minAccuracy && abs(SensorValue[armPot] - armPos) < minAccuracy;
}

bool moveToDefault()
{
	return moveTo(armDefault, liftDefault, 1);
}



//stacks a cone, returns if the stack is complete or not
bool stack()
{
	 //if there are still states to go through, keep going through them.
	 if(stackState < numStackStates)
 	 {
 	    //get the lift stack value, parses the string and incorporates stack height
 	    string liftStackValStr = liftStackValues[stackState];
 	    int liftStackVal = 0;
 	    int strStartIndex = stringFind(liftStackValStr, "+STACK_HEIGHT");
 	    if(strStartIndex != -1)
		 	{
		 		  stringDelete(liftStackValStr, strStartIndex, 13);
		 		  liftStackVal = liftConeValues[numCones];
		 	}
			liftStackVal += atoi(liftStackValStr);

			//move to the correct position
			if(moveTo(armStackValues[stackState], liftStackVal, rollerStackValues[stackState]))
			{
				//if we got to the right position, then increase the lift state.
				stackState++;
			}
			return false;
	 }
	 stackState = 0;
	 return true;
}

//cancels a stack in progress
bool cancelStack()
{
	 stackState = 0;
	 stackComplete = true;
	 return moveToDefault();
}

//clears the stack
bool clearStack()
{
	numCones = 0;
	stackState = 0;
	cancelStackComplete = true;
  stackComplete = true;
	return moveToDefault();
}


//returns 0 for no flick, 1 for up, -1 for down.
//to complete a flick, you must hit the end of the joystick and then release it in less than 1 second.
int flick(int input)
{
	 //if we hit the top less than 1 second ago,
	 if(hit != 0)
	 {
	    //and now we're close to zero,
			if(abs(input) < 10)
			{
				 //we flicked! return the direction of the flick.
				 int temp = hit;
				 hit = 0;
				 return temp;
			}
			//if it's longer than a second, we didn't flick. set hit to zero
			if(time1[T1] > 1000)
			{
				 hit = 0;
			}
	 }

	 //if we're close to the max value
	 if(127 - abs(input) < 10)
	 {
	    //if input is negative, then the flick will be -1, otherwise, it's +1
		  if(input < 0)
			{
					hit = -1;
			}
			else
			{
					hit = 1;
			}
			//start the timer
			clearTimer(T1);
	 }

	 //if nothing happens, return 0.
	 return 0;
}

void mobileGoal(bool upButton, bool downButton)
{
	 if(upButton && !downButton)
	 {
		 motor[mogo] = 127;
	 }
	 else if (downButton && !upButton)
	 {
		 motor[mogo] = -127;
	 }
	 else
	 {
		 motor[mogo] = 0;
	 }
}

//returns if the manual override is being used, also controlls the lift
bool manualLiftOverride(bool upButton, bool downButton)
{
	 if(upButton && !downButton)
	 {
		 motor[lift] = 127;
	 }
	 else if (downButton && !upButton)
	 {
		 motor[lift] = -127;
	 }
	 else if (downButton && upButton)
	 {
		 motor[lift] = 0;
	 }
	 return !upButton && !downButton;
}


task main()
{
	 //assigns all important values at the start of the program.
	 assign();

	 //don't ever exit driver control
	 while(true)
	 {
	   	//run drive w/left joystick
			drive(vexRT[Ch3], vexRT[Ch4]);

			//run mobile goal w/right bumper
			mobileGoal(vexRT[Btn6U],vexRT[Btn6D]);

			//run lift override w/left bumper, don't run any arm/roller/lift code while this is running
			if(manualLiftOverride(vexRT[Btn5U], vexRT[Btn5D]))
			{
				 //if any action is going on, abort it.
				 cancelStackComplete = true;
				 clearStackComplete = true;
				 stackComplete = true;
				 return;
			}

			//get the flick direction on the right joystick, both in x and y directions
			int flickDirX = flick(vexRT[Ch1]);
			int flickDirY = flick(vexRT[Ch2]);

			//if the flick direction was up, add 1 to the number of cones.
			if(flickDirY == 1)
			{
					numCones++;
			}
			//if the flick direction was down, cancel the stack procedure if it was happening, and subtract 1 from the stack of cones.
			if(flickDirY == -1)
			{
	 				numCones--;
					cancelStackComplete = false;
			}
			//if the flick direction was right, stack.
			if(flickDirX == 1)
			{
					stackComplete = false;
			}
			//if the flick direction was left, clear the stack.
			if(flickDirX == -1)
			{
					clearStackComplete = false;
			}

			//clear stack overrides cancel stack and stack and default
			if(!clearStackComplete)
			{
					clearStackComplete = clearStack();
					continue;
			}

			//cancel stack overrides stack and default
			if(!cancelStackComplete)
			{
					cancelStackComplete = cancelStack();
					continue;
			}

			//stack overrides default
			if(!stackComplete)
			{
				  stackComplete = stack();
				  continue;
			}

			//if all actions are complete, and there are no overrides, then move to the default position
			moveToDefault();
	 }

}
